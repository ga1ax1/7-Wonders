
# 《七大奇迹对决》系统接口文档

**版本**: 2.6

---

## 1. 全局定义 (Global Definitions)

定义游戏的核心常量、状态机与枚举，消除魔法值。

```cpp
namespace SevenWondersDuel {

    // 资源类型 (规则 1.6)
    enum class ResourceType { 
        WOOD, STONE, CLAY,   // 棕色原料
        PAPER, GLASS         // 灰色加工品
    };

    // 卡牌类型 (规则 1.6)
    enum class CardType { 
        RAW_MATERIAL,   // 棕色
        MANUFACTURED,   // 灰色
        CIVILIAN,       // 蓝色
        SCIENTIFIC,     // 绿色
        COMMERCIAL,     // 黄色
        MILITARY,       // 红色
        GUILD,          // 紫色 (时代III专用)
        WONDER          // 奇迹
    };

    // 科学符号类型 (规则 1.7)
    // 注意：LAW (法律) 视为一种特殊符号，用于凑齐6种
    enum class ScienceSymbol { 
        GLOBE,      // 地球仪
        TABLET,     // 石板
        MORTAR,     // 研钵(烧杯)
        COMPASS,    // 圆规
        WHEEL,      // 齿轮
        QUILL,      // 羽毛笔
        LAW         // 法律 (发展标记提供)
    };

    // 游戏主状态机 (控制层核心)
    enum class GameState {
        // --- 准备阶段 ---
        WONDER_DRAFT_PHASE_1,      // 第一轮奇迹轮抽 (4张)
        WONDER_DRAFT_PHASE_2,      // 第二轮奇迹轮抽 (4张)
        
        // --- 正常回合 ---
        AGE_PLAY_PHASE,            // 玩家行动阶段 (建牌/卖牌/建奇迹)
        
        // --- 中断/交互状态 ---
        WAITING_FOR_TOKEN_SELECTION_PAIR, // 凑齐2个相同符号，从5个公开标记中选1
        WAITING_FOR_TOKEN_SELECTION_LIB,  // 亚历山大图书馆：从3个保留标记中选1
        WAITING_FOR_DESTRUCTION,          // 宙斯/竞技场：选择对手一张卡摧毁
        WAITING_FOR_DISCARD_BUILD,        // 摩索拉斯陵墓：从弃牌堆选卡建造
        WAITING_FOR_START_PLAYER_SELECTION, // 时代交替：由军事劣势方/最后出牌方决定先手
        
        // --- 结算 ---
        GAME_OVER
    };

    // 玩家行动指令类型
    enum class ActionType { 
        DRAFT_WONDER,          // 轮抽奇迹
        BUILD_CARD,            // 建造卡牌 (支付资源/金币/连锁)
        DISCARD_FOR_COINS,     // 弃牌换钱 (规则: 2 + 黄卡数)
        BUILD_WONDER,          // 建造奇迹 (作为次级目标，需垫一张时代卡)
        SELECT_PROGRESS_TOKEN, // 选择发展标记
        SELECT_DESTRUCTION,    // 指定摧毁目标
        SELECT_FROM_DISCARD    // 从弃牌堆捞牌
        CHOOSE_STARTING_PLAYER // 决定下一时代先手
    };

    // 发展标记 (规则 1.3)
    // 区分：立即型(Immediate)、被动型(Passive)、计分型(Scoring)
    enum class ProgressToken {
        AGRICULTURE,   // 农业: 立即6金，结束4分
        URBANISM,      // 都市化: 立即6金，连锁给4金
        STRATEGY,      // 战略: 红卡盾牌+1 (奇迹除外)
        THEOLOGY,      // 宗教: 奇迹获得"再来一回合"
        ECONOMY,       // 经济: 对手交易金给玩家
        MASONRY,       // 砖石: 蓝卡造价-2资源
        ARCHITECTURE,  // 建筑: 奇迹造价-2资源
        LAW,           // 法律: 科学符号+1
        MATHEMATICS,   // 数学: 每个标记3分
        PHILOSOPHY     // 哲学: 结束7分
    };

    // 胜利类型
    enum class VictoryType { NONE, MILITARY, SCIENCE, CIVILIAN };
}
```

---

## 2. 模型层 (Model Layer)

负责数据存储、状态维护与规则校验。

### 2.1 类 `GameModel`
数据聚合根。

*   **成员变量**:
    *   `players`: `std::array<std::unique_ptr<Player>, 2>`
    *   `board`: `std::unique_ptr<Board>`
    *   `currentAge`: `int` (1, 2, 3)
    *   `currentPlayerIdx`: `int` (0 或 1)
    *   `winnerIdx`: `int` (-1 表示未分胜负)
    *   `unusedProgressTokens`: `std::vector<ProgressToken>` (盒子里的标记，用于图书馆)
    *   `draftPool`: `std::vector<Wonder*>` (当前轮抽区的奇迹)
*   **核心方法**:
    *   `switchPlayer()`: 切换行动方。
    *   `checkImmediateVictory()`: 检查 `MilitaryTrack` 是否触底或 `Player` 符号是否满6种。
    *   `isWonderBuildLimitReached()`: 检查全局奇迹数是否 `< 7`。
    *   `eliminateEighthWonder()`: 当第7个奇迹建成时，移除第8个奇迹。
    *   `setupAge(int age)`: 初始化牌堆、重置版图结构（金字塔形状）。

### 2.2 类 `Player`
玩家实体。

*   **成员变量**:
    *   `coins`: `int`
    *   `builtCards`: `vector<Card*>`
    *   `builtWonders`: `vector<Wonder*>`
    *   `unbuiltWonders`: `vector<Wonder*>`
    *   `scienceSymbols`: `map<ScienceSymbol, int>` (统计每种符号数量)
    *   `ownedChainSymbols`: `set<string>` (拥有的连锁标记，如 "Moon", "Target")
    *   `activeBuffs`: `set<ProgressToken>` (拥有的被动效果标记)
*   **核心方法**:
    *   `calculateCost(Card* card, Player* opponent)`:
        *   **逻辑**:
            1. 检查 `card->chainCondition` 是否在 `ownedChainSymbols` 中 -> 免费。
            2. 计算资源缺口。
            3. 缺口资源单价 = `2 + opponent->getResourceCount(type)`。
            4. 检查是否有 `MASONRY` (若卡为蓝色) 或 `ARCHITECTURE` (若建奇迹) 减免2资源成本。
            5. 检查黄卡特权 (将特定资源交易价定为1)。
    *   `pay(int amount, Player* opponent)`:
        *   **逻辑**: 扣除金币。若 `opponent` 有 `ECONOMY` 标记且是交易产生的费用，金币给对手；否则给银行。
    *   `+ loseCoins(amount: int): void`
        *   **逻辑**: `coins = max(0, coins - amount)`。用于军事掠夺扣钱。
    *   `+ addScienceSymbol(Symbol s): void`
        *   **逻辑**: 添加符号。若 `s` 已存在，触发“配对”逻辑 (通知 Controller 转入 `WAITING_FOR_TOKEN_SELECTION_PAIR`)。
    *   `+ getVictoryPoints(Player* opponent): int`
        *   **逻辑**: 总分 = 卡牌分 + 奇迹分 + 金币分(1/3) + 军事分 + 标记分(数学/哲学/农业) + 行会分。

### 2.3 类 `Board`
桌面公共区域。

*   **成员变量**:
    *   `militaryTrack`: `MilitaryTrack`
    *   `cardStructure`: `CardPyramid` (管理牌的覆盖/被覆盖关系)
    *   `availableProgressTokens`: `vector<ProgressToken>` (桌面可见的5个)
    *   `discardPile`: `vector<Card*>`
*   **方法**:
    *   `removeCard(string cardId)`: 从金字塔移除，并翻开被释放的牌。
    *   `destroyCard(Player* target, CardType type)`:
        *   **逻辑**: 从玩家 `builtCards` 中移除指定类型卡牌，放入弃牌堆。
        *   **注意**: 需同步移除玩家的 `Resources`、`ScienceSymbols` 和 `ChainSymbols`。

### 2.4 类 `MilitaryTrack`
军事轨道与掠夺逻辑。

*   **成员变量**:
    *   `position`: `int` (-9 到 +9)。负数偏向P1，正数偏向P2。
    *   `lootZones`: `bool[4]` (标记 P1-2元, P1-5元, P2-2元, P2-5元 是否已被触发)。
*   **方法**:
    *   `applyShields(int count, Player* activePlayer)`:
        *   根据 activePlayer 方向移动。
        *   **掠夺检测**: 若移动跨过 5 或 10 的界限，且该界限的 `lootZone` 为 true：
            *   设置 `lootZone = false`。
            *   调用 `opponent->loseCoins(2 或 5)`。
            *   移除对应的 token (视觉层)。
        *   **胜利检测**: 若位置达到 +/-9，返回 `true`。

### 2.5 输入接口（AI/人工）

```cpp
class IPlayerAgent {
public:
    virtual ~IPlayerAgent() = default;

    // 核心决策函数
    // 传入：当前 Model 视图（只读）
    // 返回：决定的 Action
    virtual Action decideNextMove(const GameModel& model) = 0;
    
    // 决定先手时的回调
    virtual int decideStartingPlayer(const GameModel& model) = 0;
};

// 实现类
class HumanAgent : public IPlayerAgent { /* 等待 UI 输入 */ };
class AI_RandomAgent : public IPlayerAgent { /* 随机合法步 */ };
class AI_MinimaxAgent : public IPlayerAgent { /* 搜索算法 */ };
```



---

## 3. 控制层 (Controller Layer)

### 3.1 类 `GameController`
处理游戏流程与规则裁决。

*   `std::vector<Action> getLegalActions() const`
    *   获取当前玩家所有合法的操作列表
    *   UI 用于高亮可选项，AI 用于决策遍历

*   `ActionResult validateAction(const Action& action) const`
    *   预检查某个动作是否合法（及具体费用）
    *   返回值结构体(6.3)包含：isValid, cost, errorMsg

*   `processAction(Action action)`
    *   **逻辑详情**:
        *   **BUILD_CARD (建造卡牌)**
            *   验证 `cardId` 是否在金字塔可选区。
            *   调用 `player->calculateCost`。
            *   `player->pay`。
            *   若 `calculateCost` 判定为连锁免费 (`Chain`) 且玩家有 `URBANISM` 标记 -> `player->addCoins(4)`。
            *   `player->addCard(card)` -> 触发 `IEffect::apply`。
            *   **配对检查**: 若获得第2个相同科学符号 -> 状态转为 `WAITING_FOR_TOKEN_SELECTION_PAIR`。

        *   **BUILD_WONDER (建造奇迹)**
            *   验证 `GameModel::isWonderBuildLimitReached()`。
            *   支付奇迹成本。
            *   将垫材卡移入 `builtWonders` 下方。
            *   触发奇迹效果。
            *   **特殊跳转**:
            *   若奇迹是 *The Great Library* -> 状态转为 `WAITING_FOR_TOKEN_SELECTION_LIB`。
            *   若奇迹是 *Mausoleum* -> 状态转为 `WAITING_FOR_DISCARD_BUILD`。
            *   若奇迹是 *Zeus/Circus* -> 状态转为 `WAITING_FOR_DESTRUCTION`。
            *   **再来一回合判定**: 检查奇迹自身是否有 `ExtraTurn` 或玩家有 `THEOLOGY` 标记。

        *   **DISCARD_FOR_COINS (弃牌换钱)**
            *   玩家获得 `2 + builtYellowCards` 金币。
            *   卡牌入弃牌堆。

        *   **SELECT_DESTRUCTION (摧毁卡牌)**
            *   验证目标卡牌类型是否符合当前效果要求 (如宙斯只能拆棕，竞技场拆灰 - 根据规则书具体描述，若规则书混淆，建议按 CardType 过滤)。
            *   执行 `board->destroyCard`。
            *   状态回归 `AGE_PLAY_PHASE`。

        *   **handleAgeEnd() (时代结束处理)**
            *   检查军事轨道位置。
            *   若 `position == 0`，由该时代最后出牌者决定下时代先手。
            *   若 `position != 0`，由军事弱势方决定先手。


---

## 4. 引擎层 (Engine - Effects System)

使用策略模式实现卡牌与奇迹效果。

### 4.1 接口 `IEffect`
所有效果的基类。

```cpp
class IEffect {
public:
    // 建造时触发 (立即效果)
    virtual void apply(Player* self, Player* opponent, GameController* ctx) = 0;
    
    // 游戏结束时触发 (计分效果)
    virtual int calculateScore(const Player* self, const Player* opponent) const { return 0; }
};
```

### 4.2 具体效果实现类

1.  **`ProductionEffect`**: 产出资源。
    *   属性: `resources` (map), `isChoice` (是否多选一，如灯塔)。
2.  **`MilitaryEffect`**: 军事力量。
    *   属性: `shieldCount`。
    *   逻辑: `ctx->getBoard()->moveMilitary(shieldCount + (self->hasBuff(STRATEGY) ? 1 : 0))`. (注意：STRATEGY 仅对红卡生效，奇迹不生效，需通过标记区分源头)。
3.  **`ScienceEffect`**: 科技。
    *   属性: `symbol`.
    *   逻辑: `self->addScienceSymbol(symbol)`.
4.  **`CoinEffect`**: 金币。
    *   属性: `amount`, `triggerType` (立即 / 按黄卡数 / 按奇迹数)。
    *   逻辑: 用于行会卡 (规则 1.5.4) 和商业卡。
5.  **`GuildEffect`** (行会专用):
    *   属性: `GuildType` (贸易/船主/建筑等)。
    *   **apply**: 立即给钱。
        *   例 `TradeGuild`: `count = max(self->yellowCards, opponent->yellowCards); self->addCoins(count * 1);`
    *   **calculateScore**: 结束给分。
        *   例 `TradeGuild`: `return count * 1;`
        *   例 `BuildersGuild`: `return maxWonders * 2;`
6.  **`DestructionEffect`**:
    *   属性: `targetColor`.
    *   逻辑: `ctx->setState(WAITING_FOR_DESTRUCTION, targetColor)`.
7.  **`LibraryEffect`**:
    *   逻辑: `ctx->setState(WAITING_FOR_TOKEN_SELECTION_LIB)`.
8.  **`ResurrectEffect`**:
    *   逻辑: `ctx->setState(WAITING_FOR_DISCARD_BUILD)`.

---

## 5. 视图层 (View Layer)

### 5.1 数据渲染接口
UI 仅负责根据 Model 渲染，不含逻辑。

*   `renderBoard(Board* board)`: 绘制金字塔、弃牌堆顶。
*   `renderPlayer(Player* p)`: 显示资源、金币、已建卡堆叠（按颜色分类）。
*   `renderMilitary(MilitaryTrack* track)`: 显示冲突标记位置、掠夺标记状态。
*   `renderDraft(vector<Wonder*> wonders)`: 轮抽阶段显示。
*   `renderSelectionDialog(vector<Option> options)`: 通用选择弹窗 (选Token、选产出、选被炸的卡)。

---

## 6. 辅助工具 (Utils)

### 6.1 `Card` 数据结构
为了支持 JSON/Config 加载，卡牌不应硬编码。

```cpp
struct CardData {
    string id;
    int age;
    CardType type;
    vector<ResourceType> costResources;
    int costCoins;
    string chainTag;         // 此卡拥有的标签 (如 "Moon")
    string providedChainTag; // 此卡提供的后续免费标签 (如 "Sun")
    vector<shared_ptr<IEffect>> effects;
};
```

### 6.2 结构体 `Action` 

```cpp
struct Action {
    ActionType type;

    // 1. 主要目标 ID
    // 用途: 
    // - BUILD_CARD / DISCARD: 选中的金字塔卡牌 ID
    // - BUILD_WONDER: 被垫在奇迹下面的金字塔卡牌 ID
    // - SELECT_DESTRUCTION: 选中的对手卡牌 ID
    // - SELECT_FROM_DISCARD: 选中的弃牌堆卡牌 ID
    std::string targetCardId; 

    // 2. 次要目标 ID / 辅助参数
    // 用途:
    // - BUILD_WONDER: 玩家手中要建造的那张奇迹的 ID
    std::string targetWonderId;

    // 3. 选中的标记 (仅用于 SELECT_PROGRESS_TOKEN)
    ProgressToken selectedToken = ProgressToken::NONE;
    
    // 4. (可选) 产出选择
    // 用途: 只有在极少数多选一产出无法自动判定时使用 (如灯塔/比雷埃夫斯港)
    // 大多数情况 Model 会自动计算最优资源解，不需要此参数
    ResourceType chosenResource = ResourceType::WOOD; 
  
    int chosenPlayerIndex; //配合 CHOOSE_STARTING_PLAYER 使用 (0或1)
};
```

### 6.3 结构体`ActionResult`

```cpp
struct ActionResult {
    bool isValid;
    int actualCost;    // 计算了减免、交易后的实际费用
    std::string error; // 例如 "资源不足" 或 "被上层卡牌覆盖"
};
```

### 6.4 数据加载接口

Card 和 Wonder 的数据（消耗、效果、名称）目前没有来源。不能硬编码在 C++ 里，通常需要从 JSON/XML/CSV 加载。

```cpp
class IDataLoader {
public:
    virtual ~IDataLoader() = default;
    
    // 从文件加载所有卡牌定义
    virtual std::vector<CardData> loadCards(const std::string& filepath) = 0;
    
    // 从文件加载所有奇迹定义
    virtual std::vector<WonderData> loadWonders(const std::string& filepath) = 0;
};
```

## 7. UML

```tex
+-----------------------------------------------------------------------------------+
|                                 CONTROLLER LAYER                                  |
|  (负责流程控制，不再作为被观察，而是主动调用 View 和 Model)                 						 |
+-----------------------------------------------------------------------------------+
                                         |
 +-----------------------+               |
 |    GameController     |               |
 +-----------------------+               |
 | - model: GameModel*   |               |
 | - view: GameView*     |               |
 | - loader: IDataLoader*|               |
 +-----------------------+               |
 | + initializeGame()    |               v
 | + getLegalActions()   | ------------------------------> +----------------------+
 | + validateAction()    | Uses (DTO)                      |        Action        |
 | + processAction()     |                                 +----------------------+
 | - handleAgeEnd()      |                                 | + type: ActionType   |
 +-----------+-----------+                                 | + targetCardId       |
             |                                             | + targetWonderId     |
             | Manages                                     | + selectedToken      |
             v                                             +----------------------+
 +-----------------------+
 |       GameModel       | <-----------------------------------------+
 +-----------------------+                                           |
 | - players: Player[2]  |                                           |
 | - board: Board        | Reads (for Decision Making)               |
 | - currentAge: int     |                                           |
 | - draftPool: Wonder*  |                                           |
 +-----------------------+                                           |
 | + setupAge()          |                                           |
 | + checkImmVictory()   |                                           |
 | + switchPlayer()      |                                           |
 | + eliminate8thWonder()|                                           |
 +-----+----------+------+                                           |
       |          |                                                  |
       |          | Composition                                      |
       |          v                                                  |
       |    +-----------------------+                                |
       |    |         Board         |                                |
       |    +-----------------------+                                |
       |    | - militaryTrack       |                                |
       |    | - cardStructure       |                                |
       |    | - discardPile         |                                |
       v    +----------+------------+                                |
+--------------+       |                                             |
|    Player    |       | Composition                                 |
+--------------+       v                                             |
| - coins      | +------------------+                                |
| - builtCards | |  MilitaryTrack   |                                |
| - activeBuffs| +------------------+                                |
| - sciSymbols | | - position: int  |                                |
+--------------+ | - lootZones[]    |                                |
| + calcCost() | | + applyShields() |                                |
| + pay()      | +------------------+                                |
| + loseCoins()|                                                     |
+------+-------+                                                     |
       |                                                             |
       | Holds (via builtCards)                                      |
       v                                                             |
+-------------------------------------------------------+            |
|                ENGINE LAYER (Strategy)                |            |
+-------------------------------------------------------+            |
                                                                     |
                 +-------------------+                               |
                 |      IEffect      | <<Interface>>                 |
                 +-------------------+                               |
                 | + apply()         |                               |
                 | + calculateScore()|                               |
                 +---------+---------+                               |
                           ^                                         |
        Realizes           |                                         |
+------------------+-------+----------+------------------+           |
|                  |                  |                  |           |
|  ProductionEff   |   MilitaryEff    |     GuildEff     |   ...     |
|                  |                  |                  |           |
+------------------+------------------+------------------+           |
                                                                     |
+-------------------------------------------------------+            |
|                INPUT & VIEW LAYER                     |            |
+-------------------------------------------------------+            |
                                                                     |
   +------------------+          +-------------------------+         |
   |     GameView     |          |      IPlayerAgent       |         |
   +------------------+          +-------------------------+         |
   | + renderBoard()  |          | + decideNextMove()      | --------+
   | + renderPlayer() |          | + decideStartingPlayer()|
   | + renderDraft()  |          +-----------+-------------+
   +------------------+                      ^
                                             | Realizes
                           +-----------------+------------------+
                           |                                    |
                    +------+-------+                    +-------+-------+
                    |  HumanAgent  |                    | AI_Minimax... |
                    +--------------+                    +---------------+

+-------------------------------------------------------+
|                   UTILS & DATA                        |
+-------------------------------------------------------+

  +-------------------+        +--------------------+
  |    ActionResult   |        |    IDataLoader     |
  +-------------------+        +--------------------+
  | + isValid: bool   |        | + loadCards()      |
  | + actualCost: int |        | + loadWonders()    |
  | + error: string   |        +--------------------+
  +-------------------+
```

## 8. 补充解释

### 8.1 关于卡牌堆叠

`Board` 类包含了一个名为 `cardStructure` (类型为 `CardPyramid`) 的成员。

虽然文档中将其概括为一个对象，但在具体的工程实现中，**它确实需要使用“图（Graph）”结构，具体来说是一个“有向无环图（DAG）”** 来体现堆叠、覆盖和翻开的逻辑。

以下是这一逻辑在系统中的具体体现方式：

#### 8.1.1 数据结构设计：有向无环图 (DAG)

在《七大奇迹对决》中，卡牌的排列不是简单的二维数组，而是基于**依赖关系**的。
*   **节点 (Node)**: 代表桌面上的位置（包含一张 `Card` 实例、当前是正面还是背面）。
*   **边 (Edge)**: 代表“覆盖”关系。如果卡牌 A 压在卡牌 B 上，则存在从 A 指向 B 的一条边（或者反过来，取决于你如何定义依赖，通常记录“谁压着我”）。

在 `CardPyramid` 类内部，通常会定义一个内部结构体来管理这些关系：

```cpp
// 补充细节：CardPyramid 内部实现原理
class CardPyramid {
private:
    struct Slot {
        std::string id;          // 卡牌唯一ID
        Card* card;              // 指向实际卡牌数据的指针
        bool isFaceUp;           // 当前是否正面朝上
        bool isRemoved;          // 是否已被拿走
        
        // 关键逻辑：图的邻接表表示
        // covers: 我压着谁 (用于移除我时，通知下面的牌)
        std::vector<int> coversIndices; 
        
        // coveredBy: 谁压着我 (入度，当此列表为空时，我才可被选取)
        std::vector<int> coveredByIndices; 
    };

    std::vector<Slot> slots; // 存储当前时代所有卡牌位置

public:
    // 获取当前可选的卡牌列表 (即入度为0且正面朝上的卡)
    std::vector<Card*> getAvailableCards();
    
    // 拿走一张卡，并处理翻面逻辑
    void removeCard(std::string cardId);
};
```

#### 8.1.2 逻辑流程：堆叠与翻开

这个逻辑主要体现在 `GameModel` 调用 `Board` 的 `removeCard` 方法时。

##### A. 初始化 (SetupAge)

每个时代（Age 1, 2, 3）的形状是固定的。在 `GameModel::setupAge(int age)` 时，系统会加载预设的图结构：
*   **Age 1 (金字塔)**: 底层由上层覆盖。例如，第2行的牌会被第1行的牌压住。
*   **设置依赖**: 代码会硬编码这些关系。例如 `slot[5].coveredBy = {2, 3}` (索引5的牌被2和3压住)。
*   **设置朝向**: 根据规则书，特定行初始化为 `isFaceUp = false`，其余为 `true`。

##### B. 移除卡牌与连锁翻开 (Remove Logic)

这是图结构发挥作用的核心时刻。当玩家选择拿走卡牌 X 时：

1.  **检查合法性**: 检查 X 的 `coveredByIndices` 是否为空。如果不为空，说明它被压着，不可拿取。
2.  **物理移除**: 将 X 标记为 `isRemoved = true`。
3.  **更新依赖 (BFS/遍历)**:
    *   找到 X 压着的所有下层卡牌 Y (遍历 X 的 `coversIndices`)。
    *   从 Y 的 `coveredByIndices` 列表中移除 X。
    *   **翻面判定**: 检查 Y 更新后的 `coveredByIndices` 是否为空（即是否不再被任何牌压住）。
    *   如果 Y 现在没有被压住 (**入度变为0**)，且 Y 原本是背面朝上 (`isFaceUp == false`)，则将 Y 设为 `isFaceUp = true`。

### 8.2 关于卡牌信息的一些问题

#### 问题一：卡片信息是否需要按种类派生（继承 vs 组合）？

**结论：强烈建议不要使用继承（`class MilitaryCard : public Card`），而是使用“组合模式 + 数据驱动”。**

##### 为什么不推荐继承？

1.  **类爆炸**: 如果你为红卡、蓝卡、绿卡都写一个子类，代码会变得冗余。
2.  **混合属性**: 《七大奇迹对决》中有一些特殊的牌可能同时具有多种特性（虽然基础版较少，但考虑到扩展性）。例如，如果一张牌既给分又给钱，它该继承 `ScoreCard` 还是 `CoinCard`？多重继承是噩梦。
3.  **数据与行为分离**: 卡牌本质上是数据的集合（费用、图片、名字）。它的“特殊性”在于它的**效果（Effect）**。

##### 推荐方案：单一 `Card` 类 + `IEffect` 组合

正如之前的 UML 设计所示，`Card` 应该是一个**具体的类（Concrete Class）**或结构体，它通过持有不同的数据来区分种类。

**设计方式：**

```cpp
// 1. 只有一种 Card 类
class Card {
public:
    std::string id;
    CardType type;          // 枚举：MILITARY, CIVILIAN, etc.
    ResourceCost cost;      // 结构体：造价
    std::string chainTag;   // 连锁标签
    
    // 核心：卡牌的效果是挂载上去的组件
    std::vector<std::shared_ptr<IEffect>> effects; 
    
    // 只是一个简单的取值方法
    int getPoints(Player* self, Player* opp) {
        int total = 0;
        for(auto& eff : effects) total += eff->calculateScore(self, opp);
        return total;
    }
    
    void onBuild(Player* self, Player* opp, GameController* ctx) {
        for(auto& eff : effects) eff->apply(self, opp, ctx);
    }
};
```

**如何区分不同卡牌？**
在数据加载阶段（Factory模式），根据 JSON/配置文件的内容组装对象：

*   **伐木场 (棕卡)**:
    *   `type` = `RAW_MATERIAL`
    *   `effects` = `[ ProductionEffect({WOOD: 1}) ]`
*   **兵营 (红卡)**:
    *   `type` = `MILITARY`
    *   `effects` = `[ MilitaryEffect(1) ]`
*   **贸易商行会 (紫卡)**:
    *   `type` = `GUILD`
    *   `effects` = `[ GuildEffect(TRADE_TYPE) ]`

**优点**：
*   所有卡牌类型统一，容器（`vector<Card*>`）处理方便。
*   卡牌逻辑完全由数据文件定义，修改数值不需要重新编译代码（如果做了 JSON 解析）。

#### 问题二：每个时代开始时的抽取是怎么实现的？

**结论：不要从“总卡堆”里遍历查找。应在游戏初始化时建立“分桶牌库”，然后在 Setup 阶段进行随机移除和混合。**

实现逻辑分为 **数据加载期** 和 **游戏初始化期**。

##### 1. 数据结构：牌库分桶
在 `GameController` 或 `GameModel` 中，维护分类好的牌库缓冲池：

```cpp
// 原始数据池 (从文件加载后，按时代分类存放)
struct CardPool {
    std::vector<Card> age1Cards;
    std::vector<Card> age2Cards;
    std::vector<Card> age3Cards;
    std::vector<Card> guildCards; // 紫卡单独放
};
```

##### 2. 实现流程 (Setup Logic)

当游戏开始或进入新时代时，按照规则构建当前的**游戏牌堆 (Play Deck)**。

**规则回顾：**
*   **时代 I**: 基础牌中随机移除 3 张。
*   **时代 II**: 基础牌中随机移除 3 张。
*   **时代 III**: 基础牌中随机移除 3 张，然后混入 3 张随机的行会卡。

**C++ 实现伪代码：**

```cpp
class GameController {
private:
    CardPool fullPool; // 加载的所有原始卡牌数据

public:
    // 准备指定时代的牌堆
    std::vector<Card*> prepareAgeDeck(int age) {
        std::vector<Card*> deck;
        
        // 1. 复制对应时代的所有基础卡（使用指针或拷贝副本）
        if (age == 1) {
            deck = copyToPtrVector(fullPool.age1Cards);
        } else if (age == 2) {
            deck = copyToPtrVector(fullPool.age2Cards);
        } else if (age == 3) {
            deck = copyToPtrVector(fullPool.age3Cards);
        }

        // 2. 洗牌 (使用 C++ 标准库)
        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(deck.begin(), deck.end(), g);

        // 3. 移除 3 张卡 (规则：每时代都要移除3张)
        // 注意：时代3是先移除3张基础卡，再加行会卡
        for (int i = 0; i < 3; ++i) {
            if (!deck.empty()) deck.pop_back(); 
        }

        // 4. 时代 III 的特殊处理：混入行会卡
        if (age == 3) {
            // 拿出所有行会卡
            std::vector<Card*> guilds = copyToPtrVector(fullPool.guildCards);
            std::shuffle(guilds.begin(), guilds.end(), g);
            
            // 取前 3 张行会卡加入 deck
            for (int i = 0; i < 3; ++i) {
                deck.push_back(guilds[i]);
            }
            
            // 再次洗牌，确保行会卡和普通卡混合
            std::shuffle(deck.begin(), deck.end(), g);
        }

        return deck; // 返回准备好的、用于摆放金字塔的牌
    }
};
```

##### 3. 摆放进版图 (Fill Pyramid)
拿到 `deck` 后，按顺序填充到我们在上一轮讨论的 **DAG 图结构 (`CardPyramid`)** 中。

```cpp
void GameModel::setupAge(int age) {
    // 1. 获取洗好、剪裁好的牌
    std::vector<Card*> deck = controller->prepareAgeDeck(age);
    
    // 2. 填充到版图的 Slot 中
    int cardIndex = 0;
    for (auto& slot : board->cardStructure.slots) {
        if (cardIndex < deck.size()) {
            slot.card = deck[cardIndex++];
            // 根据规则设置是否正面朝上 (硬编码规则，例如Age1的第2行是反面)
            slot.isFaceUp = checkFaceUpRule(age, slot.rowIndex); 
        }
    }
}
```






LO02 - 2025 年秋季 - 七大奇迹对决本项目旨在设计并开发一款用于游玩桌游《七大奇迹：对决》（7 Wonders Duel）的应用程序。该游戏由Antoine Bauza 和 Bruno Cathala 创作，Repos Production 发行。这款专为两人设计的桌游，融合了《七大奇迹》系列的经典元素，并加入了更适合双人游戏的机制。如需了解更多游戏信息，请参阅游戏规则。建议您先进行几轮试玩，以便充分理解游戏机制。此外，您还可以观看众多相关的视频教程。1. 预期功能该应用程序需要允许玩家以主机模式进行游戏。两名玩家都可以是真人玩家，也可以是虚拟玩家（由人工智能模拟玩家）。2 界面元素应用程序必须允许用戶配置游戏：玩家设置（名称、玩家类型（人机）、AI 难度级别）；启用扩展程序（如有）；以及至少一种 AI 类型。您可以开发一个非常简单的 AI，根据可用选项做出随机决策。应用程序必须允许用戶进行游戏、查看玩家操作并确定获胜者。您可以自由地以控制台模式组织界面，只要确保便于用戶控制应用程序即可。视觉效果必须足以让用戶了解游戏状态。3. 应用演进应用程序的架构必须允许集成新功能，而无需对现有代码进行重大更改（或至少只需进行极少的更改）。因此，设计选择必须确保应用程序的可扩展性，同时不影响程序的其他部分。具体而言，它们必须保证能够轻松添加以下组件：添加新的 AI 玩家；添加扩展包（例如 Agora 或Pantheon）。您需要在报告中阐述架构的合理性，具体方法是解释如何添加这些元素（例如要创建的类、如何将其集成到架构中、可能需要进行的代码修改等）。您无需实现任何扩展功能。

4. 说明：本项目需以 5 至 6 名学生为一组完成；您可以自由地重复使用和修改教程中已开发的类，以使其适应您的需求。架构；除了 C++/C++11/C++14/C++17/C++20 的标准指令外，您还可以使用C++/C++11/C++14/C++17/C++20 的全套标准库。5. 预期交付成果最终交付成果包含以下要素：源代码：项目的全部源代码。注意：请勿提供可执行文件或目标文件。带有音频解说的演示视频：一段演示视频，其中您将展示并评论您的应用程序，以证明每个预期功能的正确运行（最多 10 分钟，99 MB）。报告：一份 .pdf 格式的报告（最多 15-20 ⻚），包含以下部分：应用程序功能的概述（具体说明预期操作）。（已实现和未实现的功能）；架构的精确描述，并解释您的选择；详细论证您的架构如何便于未来开发（参⻅上文解释）。您需要提供 UML 图，正确（且在适当的级别）展示您描述的各个子部分。项目实际进度安排的详细描述；每位组员个人贡献的详细描述（本部分将用于评分）。您将以项目总贡献的百分比来评估每位组员的贡献。每位组员还必须报告其投入项目的小时数估算。本报告可直接使用会议记录中已有的相关部分。所有交付成果最迟必须在 2026 年 1 月 4 日晚上 11:59 之前提交（全球）。6. 评估项目评价等级（满分 20 分）：所要求功能的覆盖范围：10 分；设计和架构选择：5 分；尤其要评估架构适应变化的能力；交付成果评估：5 分（视频、源代码、报告、遵守说明）。7 条建议：预计平均每周工作时间约为 5 至 6 小时，在项目开展的 8 周内，每位成员每周都需要完成一定数量的任务。因此，稳步推进至关重要，切勿等到最后 2-3 周才开始行动。强烈建议使用版本控制软件来促进协作。


一些教程会使用与项目相关的通用概念，帮助你熟悉即将开发的应用程序的不同实体。请注意，这些教程中提出的问题并不一定构成项目的实际架构。项目中最具挑战性的部分是架构设计：你应该将精力和时间集中在这部分。难点之一在于整个学期中对面向对象概念的掌握，这无疑会给你的架构设计带来挑战。建议你至少学习以下几种设计模式，它们对项目架构的开发可能有所帮助：装饰器模式、工厂模式、抽象工厂模式、建造者模式、桥接模式、组合模式、迭代器模式、模板方法模式、适配器模式、访问者模式、策略模式、外观模式和备忘录模式。除了提供设计思路之外，这些学习还能让你熟悉主要的架构模式。请注意，这并不意味着你必须使用它们。应用程序的外观不会影响评分。最重要的是，要专注于功能性。只要能正常运行，即使外观不太美观也没关系。尤其需要注意的是，各种视觉元素的设计不需要非常复杂：只需要保证游戏性即可。